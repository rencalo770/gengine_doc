# 最佳实践
- 从各种业务场景使用gengine经验总结分析来看,难以注意或难以测试的问题都是并发安全问题


### 实例1
- 直接使用gengine单实例注意事项<br/>
<font color=red >在执行规则时,一个gengine实例中的规则是有状态的,这个状态从规则执行开始,到代码中不使用这个gengine实例使用过的变量为止 </font>.言下之意是,如果第二请求在第一个请求的状态未完结的情况下,使用第一个请求使用的gengine实例,即使是顺序执行,
也会引起并发问题(如map并发读写panic, 数据状态变更不符合预期),通常,这是很难被注意到的一点.
因此真实的业务场景中,应该要注意2点：
1. 不同的请求之间的状态不应该有重叠,当处于并发场景下,每次请求应该独享一个gengine实例,直至状态结束,才能被释放
2. 每次请求之间尽量不要共享变量,如果确实要共享,也要保证并发安全(如果这个不能保证,即使不使用gengine,也一样会有并发问题)
3. 推荐使用gengine pool

- 举例：

```golang

//明日补上

```






### 实例2
- 使用线程池注意事项<br/>
<font color=red >使用gengine池时,池保证了实例之间是隔离的,但池也无法保证用户注入到池中的gengine实例中的变量是不共享或线程安全的</font>,
因此,为了避免并发安全问题,每次取一个池中gengine实例执行规则时,用户注入到实例中的变量最好是新实例化出来的变量来重新注入,或者是线程安全的.

```golang

//明日补上

```


